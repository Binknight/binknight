package org.binknight.dp;

public class dp_01 {
    /**
     * 动态规划适合解决的问题的模型。我把这个模型定义为“多阶段决策最优解模型”
     * 1. 最优子结构 最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，
     * 我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到
     * 我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过
     * 前面阶段的状态推导出来。
     *
     * 2. 无后效性  无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我
     * 们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义
     * 是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的
     * 要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。
     *
     * 3. 重复子问题 这个概念比较好理解。前面一节，我已经多次提过。如果用一句话概括
     * 一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。
     */

    /** DP问题
     * 假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在
     * 左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移
     * 动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起
     * 来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？
     *
     * * private int[][] matrix = {
     *      * {1，3，5，9},
     *      * {2，1，3，4}，
     *      * {5，2，6，7}，
     *      * {6，8，4，3}};
     */

    public static void main(String[] args) {
        int[][] matrix = {
                {1, 3, 5, 9},
                {2, 1, 3, 4},
                {5, 2, 6, 7},
                {6, 8, 4, 3}};

        System.out.println(minDistDp(matrix,4));
    }

    private static int minDistDp(int[][] matrix, int n) {
        int[][] states = new int[n][n];
        // 初始化第一行的状态，即最小距离集合
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += matrix[0][i];
            states[0][i] =sum;
        }

        // 初始化第一行的状态集合
        sum = 0;
        for (int j = 0; j < n; j++) {
            sum += matrix[j][0];
            states[j][0] = sum;
        }

        for (int i = 1; i < n; i++) {
            for (int j = 1; j < n; j++) {
                states[i][j] = matrix[i][j] + Math.min(states[i-1][j],states[i][j-1]);
            }
        }

        return states[n-1][n-1];
    }
}
